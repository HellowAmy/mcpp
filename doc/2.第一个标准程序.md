# 2.第一个标准程序


## 标准程序
#### main.cpp
~~~
/*
    这是多行注释，在标记结束前都是注释内容，可以有很多行
    多行注释主要用于集中描述复杂功能，或者给开发者提供帮助
    注释内容不是运行代码的一部分，仅仅是用于开发者了解程序设计
    这是一个简单的 C++ 代码文件，用于在终端中打印 hello world
    编写注释是一个很好的习惯，请保持编写你的设计思路
    正如你现在所看到的，现在这一份代码充满了注释
*/

// 这是单行注释，单行注释用于在注释下方，一行或连续多行的代码功能
// 这是包含标准库（STL）头文件的代码
#include <iostream>

// 宏定义（macro）：
// 一个用于打印到终端的宏
#define MCLOG(value) std::cout << value << " [" << __FILE__ << ":" << __LINE__ << "]" << std::endl;

// 一个用于设置参数的宏
#define $(value) "[" #value ": " << value << "] "

// main 函数入口，一个可执行程序只能有存在唯一的一个 main 函数
// main 函数存在返回值 int 和两个传入参数 int 与 char **
// argc : 传入的参数个数
// argv : 存储的字符数据
int main(int argc, char **argv)
{
    // 打印启动参数
    std::cout << "argv: ";
    for (int i = 0; i < argc; i++)
    {
        char *val = argv[i];
        std::cout << val;
        std::cout << " ";
    }
    std::cout << std::endl;

    // C++ 常规打印
    std::cout << "hello world" << std::endl;

    // C++ 带定位的打印
    std::cout << "hello world" << " [" << __FILE__ << ":" << __LINE__ << "]" << std::endl;

    // C++ 带定位的宏打印
    MCLOG("hello world")

    // C++ 带定位和参数格式化的宏打印
    MCLOG($("hello world") $(argc))

    // main 函数返回值，通常 0 代表正常返回，负数为异常终止
    return 0;
}
~~~

#### 打印结果
~~~
argv: /home/red/open/github/mcpp/example/02/build/mcpp 
hello world
hello world [/home/red/open/github/mcpp/example/02/main.cpp:41]
hello world [/home/red/open/github/mcpp/example/02/main.cpp:44]
["hello world": hello world] [argc: 1]  [/home/red/open/github/mcpp/example/02/main.cpp:47]
~~~

这是一份标准程序，上面充满了注释，注释可以其他人读懂编写者的设计思路与目的，缺少注释会让人看不懂或者理解错误，所以注释非常重要，注释代码是 **编程规范** 的重要一步  
这一份代码看上去相当丰富，如果你看不懂别担心，我们一步一步来拆解  
如果你仔细看了上面的代码的注释，你也应该多看注释，你就会发现代码由下面的几个部分构成  

#### 代码构成
~~~
1.main函数，是C++程序的入口，是唯一且必须要存在的，main函数是拥有参数和返回值的  
2.STL标准库头文件，是C++的主要开发手段之一，包含了C++的众多功能
3.宏定义，是一种简单的文本复制功能，与手写代码完全一致，通过别名的方式进行文本复制
~~~

#### 最小代码
~~~
int main(int argc, char **argv)
{
    return 0;
}
~~~

最小代码是C++编译成可执行文件的最小需求，可以看的出，只要定义了main函数，C++代码就可以成功编译，需要注意main函数通常会传入 argc argv 两个参数，这是启动参数，argv 中至少会包含程序启动路径，你可以次从打印结果中得知
你可能会看到main函数没有参数的版本，那是不符合规范的做法，请避免这种行为  

#### 打印字符串
~~~
#include <iostream>
int main(int argc, char **argv)
{
    std::cout << "hello world" << std::endl;
    return 0;
}
~~~

经典的 "hello world" 程序，前面的最小代码虽然能执行，但没有任何输出，这份代码就可以在终端（terminal）中打印字符串  
其中引入了 iostream 头文件，这个文件包含了 cout endl 两个类对象，cout 用于将字符串推入缓冲区，还没有显示，遇到换行 '\n' 或者 endl 之后就会刷新缓冲区，然后在终端显示打印内容 
如果你发现程序并没有打印，请检查是否调用 endl 刷新缓冲区，这是新手常见问题  
C++是模块化设计的，C++本身只包含基础语法功能，想要打印字符串需要借助操作系统，而STL标准库封装了操作系统之间的差异，形成统一标准，他是官方库文件，跟随C++语言发布  
STL内的所有文件都被限制在 std:: 命名空间内，std::cout 是一种命名空间的使用方式，所以当使用STL时都会伴随着 std:: 的出现  

#### 流式打印
~~~
#include <iostream>
int main(int argc, char **argv)
{
    std::cout << "argv: ";
    for (int i = 0; i < argc; i++)
    {
        char *val = argv[i];
        std::cout << val;
        std::cout << " ";
    }
    std::cout << std::endl;
    return 0;
}
~~~

上述说 cout 是流式打印的，这个打印main函数参数的例子就很容易理解 cout 的工作原理，代码上 cout 出现了很多次，但 endl 只在结尾出现，这意味这份代码只有一行打印，可以从打印结果中得知  
cout 只负责推入内容，for 是循环的意思，它循环根据 argc 提供的个数循环的获取 argv 的字符内容，然后推入 cout 的缓冲区，但还没有打印，最后一行 "std::cout << std::endl;" 将 endl 也推出缓冲区，触发刷新缓冲区打印内容


## 日志打印
#### 宏定义与日志
~~~
#define MCLOG(value) std::cout << value << " [" << __FILE__ << ":" << __LINE__ << "]" << std::endl;

#define $(value) "[" #value ": " << value << "] "
~~~

宏定义（macro）是新手不好理解且不推荐随意使用的，但在这里第一个程序就使用了，因为我们需要打印日志  
打印日志非常中重要，通常日志需要附带 **日期时间/文件位置/代码函数** 等信息，在打印中附带日志信息可以帮助开发者调试程序  
日志信息打印是 **编程规范** 的重要一步  
但是手动编写复杂重复的日志信息又十分烦人，所以可以借助宏来完成这一步，先说宏定义的功能，它只是简单的复制你为他制定的内容，它需要你指定一个别名和原本代码，然后它会在编译时在别名位置替换为原本代码  
在这里使用的是 MCLOG 别名，MCLOG 的含义是 mcpp log 的日志打印，这是在项目名称时就决定的命名规范，要时刻记住代码命名与项目名称的关联
当然 MCLOG 宏只是提供简单的日志功能，真正的日志需求会相当复杂  
宏的使用需要谨慎且规范，宏通常是需要全部大写的，而系统自带 \_\_FILE\_\_ \_\_LINE\_\_ 通常都带有下划线前缀，所以尽量避免与系统宏命名规则冲突  
宏定义名称大写是 **编程规范** 的重要一步  

#### 编写体验
~~~
#include <iostream>

#define MCLOG(value) std::cout << value << " [" << __FILE__ << ":" << __LINE__ << "]" << std::endl;

#define $(value) "[" #value ": " << value << "] "

int main(int argc, char **argv)
{
    std::cout << "hello world 1" << " [" << __FILE__ << ":" << __LINE__ << "]" << std::endl;
    std::cout << "hello world 2" << " [" << __FILE__ << ":" << __LINE__ << "]" << std::endl;
    std::cout << "hello world 3" << " [" << __FILE__ << ":" << __LINE__ << "]" << std::endl;

    MCLOG("hello world 1")
    MCLOG("hello world 2")
    MCLOG("hello world 3")
    return 0;
}
~~~

代码的打印几结果是一致的，但从代码可以看出，MCLOG 的使用会让日志打印简单且快捷，特别是需要多次重复使用时由为明显  
宏的使用为开发者创建了一个良好的编写方式，避免了大量重复代码编写  
良好的编写体验是 **编程规范** 的重要一步  
要记住宏是一把双刃剑，使用宏是可以简化代码，同时也提升了代码复杂度，宏是可以嵌套使用的，不要过多嵌套，否则会增加他人对宏的理解难度  
不要过渡依赖宏定义，当你过渡依赖宏时，可能在程序设计上就已经出现了问题

#### 快速导航
~~~
Ctrl + 鼠标左键
~~~

附带日志信息还有一个好处，如果在使用 VSCode 运行程序，你可以使用快捷键点击打印的字符串，它会直接定位到打印日志的代码上，十分方便快捷



## 不好的习惯
#### 指名引用 - 推荐使用
~~~
#include <iostream>
int main(int argc, char **argv)
{
    std::cout << "hello world" << std::endl;
    return 0;
}
~~~

#### 区域引用 - 非常不推荐
~~~
#include <iostream>
using namespace std;
int main(int argc, char **argv)
{
    cout << "hello world" << endl;
    return 0;
}
~~~

~~~
#include <iostream>
using std::cout;
using std::endl;
int main(int argc, char **argv)
{
    cout << "hello world" << endl;
    return 0;
}
~~~

指名引用是指直接调用指定命名空间内的成员  
区域引用是指在声明区域内的可以省略命名空间直接调用命名空间内成员  
在最后提一下STL命名空间的使用，很多人不喜欢使用 std:: 这个前缀，上面提到这是一个命名空间，可以将很多的函数或者类名都限制在命名空间的作用域内，目的就是限制自己的影响力，要你指名引用
很多库都有自己的命名空间，指名引用可以让你避免很多问题，请保持这个习惯
如果你开放了作用域，可能会导致功能覆盖或者编译错误，如果发生了功能覆盖，你将非常难排查问题  
功能覆盖是多个库中存在同名函数，系统实际调用函数与你期待调用函数不一致，导致运行逻辑不一致引发的错误
指名引用是 **编程规范** 的重要一步

#### 格式化代码
~~~
Ctrl + A    // 全选
Ctrl + K    // 格式化
~~~

在结尾部分，请一定要格式化代码，应该要保持随手格式化的好习惯，也是需要反复提醒新手的地方


## 项目路径
~~~
https://github.com/HellowAmy/mcpp.git
~~~