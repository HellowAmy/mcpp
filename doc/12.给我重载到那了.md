# 给我重载到那了


## 重载符的运用
#### main.cpp
~~~
#include <iostream>

#include "mclog.h"
#include "replace_args.h"

// 存储坐标内容
class coord
{
public:
    // 无参数构造函数
    coord() {}

    // 带参数构造函数
    coord(int x, int y, int z)
        : _x(x), _y(y), _z(z) {}

    // 重载大于号对比大小
    bool operator>(const coord &other)
    {
        return cmp_greater(other);
    }

    // 重载对象本身
    operator std::string()
    {
        return to_string();
    }

    // 重载左移为按序赋值
    coord &operator<<(int num)
    {
        if (_x == 0)
        {
            _x = num;
        }
        else if (_y == 0)
        {
            _y = num;
        }
        else if (_z == 0)
        {
            _z = num;
        }
        return *this;
    }

    // 等效 bool operator>(const coord &other)
    bool cmp_greater(const coord &other)
    {
        return sum() > other.sum();
    }

    // 等效 operator std::string()
    std::string to_string()
    {
        std::string str = "[x:{0} y:{1} z:{2}]";
        str = replace_args(str)(
            "{0}", std::to_string(_x),
            "{1}", std::to_string(_y),
            "{2}", std::to_string(_z));
        return str;
    }

    // 计算总数，存在 const 声明可不变
    // 可让 const coord &other 不可变对象调用，否则无法调用
    int sum() const
    {
        return _x + _y + _z;
    }

private:
    int _x = 0;
    int _y = 0;
    int _z = 0;
};

int main(int argc, char **argv)
{
    {
        MCLOG("大于号重载 bool operator>(const coord &other)");
        coord obj1(10, 20, 30);
        coord obj2(100, 200, 300);

        // obj1 > obj2 可用，因为重载了
        // obj1 < obj2 不可用，还没有重载
        if (obj1 > obj2)
        {
            MCLOG("obj1 > obj2");
        }
        else
        {
            MCLOG("obj2 > obj1");
        }
    }
    {
        MCLOG("\n左移重载 coord &operator<<(int num)");
        coord obj1;
        coord obj2;
        obj2 << 10 << 20 << 30;

        MCLOG($(obj1.sum()) $(obj2.sum()));
    }
    {
        MCLOG("\n对象重载 operator std::string()");
        coord obj1(10, 20, 30);
        coord obj2(100, 200, 300);
        std::string str1 = obj1;
        std::string str2 = obj2;

        // 调用拷贝构造函数
        coord obj3 = obj1;

        // 调用 std::string to_string() 重载
        std::string str3 = obj3;

        MCLOG($(str1) $(str2) $(str3));
    }

    return 0;
}
~~~

#### 打印结果
~~~
大于号重载 bool operator>(const coord &other) [/home/red/open/github/mcpp/example/12/main.cpp:80]
obj2 > obj1 [/home/red/open/github/mcpp/example/12/main.cpp:92]

左移重载 coord &operator<<(int num) [/home/red/open/github/mcpp/example/12/main.cpp:96]
[obj1.sum(): 0] [obj2.sum(): 60]  [/home/red/open/github/mcpp/example/12/main.cpp:101]

对象重载 operator std::string() [/home/red/open/github/mcpp/example/12/main.cpp:104]
[str1: [x:10 y:20 z:30]] [str2: [x:100 y:200 z:300]] [str3: [x:10 y:20 z:30]]  [/home/red/open/github/mcpp/example/12/main.cpp:113]
~~~

可以从 main.cpp 文件中发现，coord 类可以实现 大小对比 左移赋值 返回字符 这几个功能，这些功能本身是无法在正常的类中得到的，他们都归功与重载符的使用  
重载符可以让类或者变量之间的运算变得简单，使得他们可以通过简单的符号去形式，但是要注意的是，重载符是成员函数的延伸，而不是单一的功能  
重载符的作用是让直到的人可以更方便的调用，不知道的人可以使用函数版本，而不是只提供重载符版本，一个类的功能应该是先提供函数，然后在基于方便使用的考量下才出重载版本  
重载符可以让事情变得有趣，他可以实现一些看起来合理的操作，比如 coord 类中，原本赋值应该需要指定 x y z 的，但是我使用了左移符号，他会看谁是空的就赋值给谁，这是不合逻辑的  
因为重载符是一个简单的符号，而不能像函数一样可以起一个直观的名称，所以重载符可能会被误解，所以重载符最好的应用应该是有常识的，比如使用 > 对比大小，使用 == 对比是否相等这类符合常识的运用   
创建符合常识的重载是 **编程规范** 的重要一步  

#### 反常识重载

一个有趣的现象 coord obj 中可以 std::string str = obj 使用对象赋值给字符串，这是意义不明的，一个反常识的内容，正是应该重载了 operator std::string() 它可以让你返回一个字符串，如果你把 operator std::string() 替换成 operator bool 那它就可以 bool ok = obj   
这取决于你希望这个类本身是什么，重载符的滥用可能会引发一些奇怪的问题，以及产生一些意义不明的代码，所以使用重载符时请谨慎  

#### 可选的重载符
~~~
+
-
*
/
%
^
&
|
~
!
=
<
>
+=
-=
*=
/=
%=
^=
&=
|=
<<
>>
>>=
<<=
==
!=
<=
>=
&&
||
++
--
,
->*
->
()
[]
~~~

C++提供的重载符号有很多，而且每个重载符需要的参数和返回值都不一样，是否只能在类中或者在全局函数外也不一致，每个重载父也可以有多种形式  
所以使用重载时需要查询他们的具体用法，具体使用方法需要自行学习  

## 项目路径
~~~
https://github.com/HellowAmy/mcpp.git
~~~