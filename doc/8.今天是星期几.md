# 今天是星期几


## 打折商品
#### main.cpp
~~~
#include <iostream>

#include "mclog.h"
#include "format.h"
#include "byte_tmp.h"

// 整数枚举类型-可进行整数转换
// 枚举星期一到星期天的类型
enum en_weekday
{
    e_monday = 1,
    e_tuesday = 2,
    e_wednesday = 3,
    e_thursday = 4,
    e_friday = 5,
    e_saturday = 6,
    e_sunday = 7,
};

// 强制枚举类型-不可进行整数转换
// 枚举出行可选的交通方式
enum class en_way
{
    e_walk,
    e_bicycle,
    e_busy,
    e_car,
};

// 结构体类型
// 声明名为购买检查项的结构体
struct shopping_check
{
    int money = 0;
    int time = 0;
    int distance = 0;
    en_way way = en_way::e_walk;
    std::string describe;
};

// 根据枚举值转化字符串
std::string to_str_enum(en_weekday en)
{
    switch (en)
    {
    case e_monday:
    {
        return "星期一";
    }
    case e_tuesday:
    {
        return "星期二";
    }
    case e_wednesday:
    {
        return "星期三";
    }
    case e_thursday:
    {
        return "星期四";
    }
    case e_friday:
    {
        return "星期五";
    }
    case e_saturday:
    {
        return "星期六";
    }
    case e_sunday:
    {
        return "星期天";
    }
    default:
        break;
    }
    return "NULL";
};

// to_str_enum 的重载版本，不同参数的处理
std::string to_str_enum(en_way en)
{
    switch (en)
    {
    case en_way::e_walk:
    {
        return "步行";
    }
    case en_way::e_bicycle:
    {
        return "单车";
    }
    case en_way::e_busy:
    {
        return "公交";
    }
    case en_way::e_car:
    {
        return "汽车";
    }
    default:
        break;
    }
    return "NULL";
}

// 返回不同类型对应的结构体信息
shopping_check get_discount_remind(en_weekday en)
{
    switch (en)
    {
    case e_monday:
    case e_tuesday:
    case e_wednesday:
    {
        shopping_check ct;
        ct.money = 10;
        ct.time = 20;
        ct.distance = 1;
        ct.way = en_way::e_walk;
        ct.describe = "楼下便利店有冰红茶买一送一活动";
        return ct;
    }
    case e_thursday:
    {
        shopping_check ct;
        ct.money = 50;
        ct.time = 12;
        ct.distance = 5;
        ct.way = en_way::e_busy;
        ct.describe = "肯德基疯狂星期四（晕公交车）";
        return ct;
    }
    case e_friday:
    {
        shopping_check ct;
        ct.money = 15;
        ct.time = 18;
        ct.distance = 3;
        ct.way = en_way::e_bicycle;
        ct.describe = "利民便利店口香糖优惠";
        return ct;
    }
    case e_saturday:
    {
        shopping_check ct;
        ct.money = 300;
        ct.time = 13;
        ct.distance = 20;
        ct.way = en_way::e_car;
        ct.describe = "胖子超市大米打折";
        return ct;
    }
    case e_sunday:
    {
        shopping_check ct;
        ct.money = 25;
        ct.time = 9;
        ct.distance = 1;
        ct.way = en_way::e_walk;
        ct.describe = "熊猫超市香蕉打折";
        return ct;
    }
    default:
        break;
    }

    return {};
}

// 打印结构体信息
void print_shopping_check(en_weekday en)
{
    // 字符串R表达式，所见所得，无需使用 \n 进行换行
    // R表达时会无视字符串的任何转换格式
    std::string str =
        R"(
不要忘记 {0} 的打折活动：{1} 
带钱：{2}块，时间：{3}点，距离：{4}公里，交通：{5}
)";

    // 格式化字符串
    // to_str_enum(ct.way) to_str_enum(en) 调用的是两个不同函数
    shopping_check ct = get_discount_remind(en);
    replace_str_ref(str, "{0}", to_str_enum(en));
    replace_str_ref(str, "{1}", ct.describe);
    replace_str_ref(str, "{2}", std::to_string(ct.money));
    replace_str_ref(str, "{3}", std::to_string(ct.time));
    replace_str_ref(str, "{4}", std::to_string(ct.distance));
    replace_str_ref(str, "{5}", to_str_enum(ct.way));
    std::cout << str << std::endl;
}

int main(int argc, char **argv)
{
    MCLOG("打印每天任务");
    print_shopping_check(e_monday);
    print_shopping_check(e_tuesday);
    print_shopping_check(e_wednesday);
    print_shopping_check(e_thursday);
    print_shopping_check(e_friday);
    print_shopping_check(e_saturday);
    print_shopping_check(e_sunday);

    MCLOG("查看枚举值");
    MCLOG("查看类型 en_weekday");
    for (int i = e_monday; i <= e_sunday; i++)
    {
        MCLOG($(i));
    }

    MCLOG("查看类型 en_way ，需要强转，非常不推荐");
    for (int i = static_cast<int>(en_way::e_walk); i <= static_cast<int>(en_way::e_car); i++)
    {
        MCLOG($(i));
    }

    /*
        // 不好的习惯：
        for (int i = (int)en_way::e_walk; i <= (int)en_way::e_car; i++)
        {
            MCLOG($(i));
        }
    */

    MCLOG("结构体二进制结构");
    struct two_int
    {
        char n1 = 1;
        char n2 = 2;
        char n4 = 4;
        char n8 = 8;
    };

    // 转为等长类型整数后打印二进制
    two_int ct;
    int ibyte;
    std::memcpy(&ibyte, &ct, sizeof(ibyte));
    std::string bit_ct = print_byte<int>(ibyte);

    // char 无法打印数据，需要转类型
    int int32_n1 = ct.n1;
    int int32_n2 = ct.n2;
    int int32_n4 = ct.n4;
    int int32_n8 = ct.n8;
    int two_int_len = sizeof(two_int);

    MCLOG($(int32_n1) $(int32_n2) $(int32_n4) $(int32_n8));
    MCLOG($(ibyte) $(two_int_len));
    MCLOG($(bit_ct));

    return 0;
}
~~~

#### format.h
~~~
#ifndef FORMAT_H
#define FORMAT_H

#include <string>

// 替换字符串，用于格式化字符串
// 在 org 字符串内，使用 str_new 替换 str_old 字符
// org : 原始内容，会被修改
// str_old : 被替换的字符
// str_new : 新字符串
void replace_str_ref(std::string &org, const std::string &str_old, const std::string &str_new);

#endif // FORMAT_H
~~~

#### format.cpp
~~~
#include "format.h"

void replace_str_ref(std::string &org, const std::string &str_old, const std::string &str_new)
{
    /*
        描述运行逻辑：
        1.查找 str_old 的位置，如果找到则使用 go 标记位置，复制 go 与 follow 之间的内容
        2.复制之后 follow 会尾随 go 的位置并跳过 str_old 字符
        3.循环使用 go 寻找下一个 str_old 字符
        4.结尾处复制 follow 位置到字符串末端，复制收尾字符
    */
    std::string ret;
    size_t go = 0;
    size_t follow = 0;
    while (true)
    {
        go = org.find(str_old, go);
        if (go == std::string::npos)
        {
            break;
        }
        ret += std::string(org.begin() + follow, org.begin() + go);
        ret += str_new;
        go += str_old.size();
        follow = go;
    }
    ret += std::string(org.begin() + follow, org.end());
    org = ret;
}
~~~

#### 打印结果
~~~
打印每天任务 [/home/red/open/github/mcpp/example/08/main.cpp:196]

不要忘记 星期一 的打折活动：楼下便利店有冰红茶买一送一活动 
带钱：10块，时间：20点，距离：1公里，交通：步行


不要忘记 星期二 的打折活动：楼下便利店有冰红茶买一送一活动 
带钱：10块，时间：20点，距离：1公里，交通：步行


不要忘记 星期三 的打折活动：楼下便利店有冰红茶买一送一活动 
带钱：10块，时间：20点，距离：1公里，交通：步行


不要忘记 星期四 的打折活动：肯德基疯狂星期四（晕公交车） 
带钱：50块，时间：12点，距离：5公里，交通：公交


不要忘记 星期五 的打折活动：利民便利店口香糖优惠 
带钱：15块，时间：18点，距离：3公里，交通：单车


不要忘记 星期六 的打折活动：胖子超市大米打折 
带钱：300块，时间：13点，距离：20公里，交通：汽车


不要忘记 星期天 的打折活动：熊猫超市香蕉打折 
带钱：25块，时间：9点，距离：1公里，交通：步行

查看枚举值 [/home/red/open/github/mcpp/example/08/main.cpp:205]
查看类型 en_weekday [/home/red/open/github/mcpp/example/08/main.cpp:206]
[i: 1]  [/home/red/open/github/mcpp/example/08/main.cpp:209]
[i: 2]  [/home/red/open/github/mcpp/example/08/main.cpp:209]
[i: 3]  [/home/red/open/github/mcpp/example/08/main.cpp:209]
[i: 4]  [/home/red/open/github/mcpp/example/08/main.cpp:209]
[i: 5]  [/home/red/open/github/mcpp/example/08/main.cpp:209]
[i: 6]  [/home/red/open/github/mcpp/example/08/main.cpp:209]
[i: 7]  [/home/red/open/github/mcpp/example/08/main.cpp:209]
查看类型 en_way ，需要强转，非常不推荐 [/home/red/open/github/mcpp/example/08/main.cpp:212]
[i: 0]  [/home/red/open/github/mcpp/example/08/main.cpp:215]
[i: 1]  [/home/red/open/github/mcpp/example/08/main.cpp:215]
[i: 2]  [/home/red/open/github/mcpp/example/08/main.cpp:215]
[i: 3]  [/home/red/open/github/mcpp/example/08/main.cpp:215]
结构体二进制结构 [/home/red/open/github/mcpp/example/08/main.cpp:226]
[int32_n1: 1] [int32_n2: 2] [int32_n4: 4] [int32_n8: 8]  [/home/red/open/github/mcpp/example/08/main.cpp:248]
[ibyte: 134480385] [two_int_len: 4]  [/home/red/open/github/mcpp/example/08/main.cpp:249]
[bit_ct: 00001000000001000000001000000001]  [/home/red/open/github/mcpp/example/08/main.cpp:250]
~~~

如果你是从第一篇开始观看这个系列的文章的，你学会了如何去编译可执行文件，学会了编写一个拥有完整控制流的程序，学会了如何优雅的管理和组织你的代码，但是你还缺少如何更好的组织数据的能力  
如果你看了上面的代码，你应该也发现了今天带来的新内容有所不同  
在 main.cpp 代码文件上，我描述了在接下来一周内，我可能前往的打折商店，我会记录他们需要的价格以及出现时间和出现方式以免错过，然后我为这个出行准备了一大堆来进行处理  
在编程中大部分时间都是在处理各种各样的数据，他们可能是简单的或者是复杂的一堆数据，我们需要的就是要处理这一堆堆的数据，那首先第一步就是要创建自己的一堆数据，以及如何使用他们  

#### 一堆数据
~~~
struct shopping_check
{
    int money = 0;
    int time = 0;
    int distance = 0;
    en_way way = en_way::e_walk;
    std::string describe;
};
~~~

我们需要去做程序的时候，总是在处理一堆数据，这一堆数据几乎都是对一件事情有着高度关联的，这时候我们需要使用结构体（struct）将他们组装在一起，让他们形成一个整体，好让我们可以更容易的修改或者使用这个结构体内的数据    
我在上面创建了一个 shopping_check 结构体，这个结构体内数据的关联是我要去购物需要注意的事项，我将所有需要提醒我出门前准备的东西都放入到这个结构体内，到时候我将可以通过这个结构体的内容获取到备忘录信息，这个结构体内的数据是高度关联的  
保持数据相关性是 **编程规范** 的重要一步  
结构体的作用就在于此，一个可以放入各种相关数据的类型，然后我们可以通过这个类型获取相关数据，如果你使用结构体，而是将数据使用普遍的变量存储，你将无法知道他们的确切关联，对想使用这些数据的开发者来讲是非常难受的  

#### 内存对齐

在结构体的数据实际存储中，操作系统中可能并不会完全根据结构体实际数据大小进行内存分配，而是分配接近结构体真实大小的出 4 或 8 的整数倍，这是操作系统在分配效率上的妥协  
正因如何，结构体内的数据类型最好能整齐堆放，同一类型的数据需要放在相邻的结构，而不是无序的排列，你会看到 shopping_check 中三个 int 类型的数据是相邻的，正是出于这种口头约束，他们根据类型的从小到大，从高到低的排序  
从小到大的内存排序是 **编程规范** 的重要一步  
当然这只是一种口头约束，在某些情况下根据名称进行排序可以有效提高可读性，这是需要进行取舍权衡的，内存对齐只是操作系统层面的东西，编程语言本身可以不关心，有关内存对齐的细节需要自行学习  

#### 请初始化数据

你可以看到在 shopping_check 上，他们的数据 money time 被成为成员变量，这些基本类型都被赋值为 0 ，这是一个好习惯，你会发现我在创建变量时，几乎都会手动去赋值，这一步叫初始化变量，这样做会让变量总是可以确认开始的值是 0 这个数字  
初始化变量是 **编程规范** 的重要一步  
结构体和变量是一样的，我们在创建他们时给他们的成员变量创建一个默认值，这是一个好习惯    
你会发现 string 我几乎不会初始化，那是因为 string 是一个类，而不是基本类型，他们本身会自己进行初始化  

#### 创建和使用数据
~~~
// 创建结构体，将数字赋值给成员
shopping_check ct;
ct.money = 15;
ct.time = 18;

// 使用结构体，将成员数据赋值给变量
shopping_check ct;
int money = ct.money;
int time = ct.time;
~~~

结构体的创建和使用都会简单，只需要在生命结构体时使用 . 操作符，他们编辑器就会提示你有什么成员可以选择  
你可以给成员赋值，或者将成员的内容赋值给其他变量，请赋值号（= 等号）的和成员的位置关系，这是新手需要注意的地方  
结构体可以看成是一个复杂类型的变量，是多个类型的结合体，他的使用其实和普通类型的变量没什么不同，你使用结构体时只需要指定你想使用的具体成员名称就可以了  
你要记住，结构体其实不复杂，只是将几个类型黏在一起的二进制而已  

#### 结构体的本质
~~~
// 打印结构体二进制
struct two_int
{
    char n1 = 1;
    char n2 = 2;
    char n4 = 4;
    char n8 = 8;
};
two_int ct;
int ibyte;
std::memcpy(&ibyte, &ct, sizeof(ibyte));
std::string bit_ct = print_byte<int>(ibyte);
MCLOG($(bit_ct));

// 打印
[bit_ct: 00001000000001000000001000000001]

/*
通过分析得出two_int内容和 n1 n2 的连续数据结构一致
    通过1248法分析结构体二进制内容
        00001000 00000100 00000010 00000001
        8        4        2        1
*/
~~~ 

通过上面的结构体二进制代码分析之后，发现存着 4char 的结构体，只是将 4char 的内容合并为一块整理，内存大小不变  
你会发现原来复杂的结构体数据原来也只是简单的内存组合而已，也就是说实际上结构体的成员数据获取和使用，也只是通过地址偏移对一整块内存的指定区域进行访问  
结构体没什么复杂的，要记住在C++中一切数据都只是二进制内存而已  

#### R表达式
~~~
void print_shopping_check(en_weekday en)
{
    // 字符串R表达式，所见所得，无需使用 \n 进行换行
    // R表达时会无视字符串的任何转换格式
    std::string str =
        R"(
不要忘记 {0} 的打折活动：{1} 
带钱：{2}块，时间：{3}点，距离：{4}公里，交通：{5}
)";
}
~~~

你发现 print_shopping_check 函数中的字符串赋值很难看了吗，它居然没有缩进结构，看起来和平时写的代码的缩进结构完全不一样，居然是顶着第一行写的  
这个字符串被 R"()" 给包裹起来，这种写法叫 R表达式 ，你要是注意看打印结果就会发现，这段字符串的打印是有换行的，但是代码没有出现 \n 等换行符，这是因为R表达式会以肉眼可见的方式转化为字符串，更符合人的文本编写，R表达式适合进行大量多行复杂本文的编辑，因为它是所见既所得的，且不需要处理转义字符    
转义字符是指和指定格式一致的文本不会被打印 ，如果我需要打印 "\n" 这个文本，我需要在代码上写  "\\n" 才行，否则打印结果是空格，而不是 "\n" 这两个字符，具体有那些转义字符你需要自行学习  
我会很不优雅的顶格写是因为打印需要顶格输出，如果我不顶格，而是在R表达式内部缩进，那打印的内容也会缩进，这是R表达式的特点，请记住这一点区别  


## 枚举类型
#### 枚举所有可能
~~~
enum en_weekday
{
    e_monday = 1,
    e_tuesday = 2,
    e_wednesday = 3,
    e_thursday = 4,
    e_friday = 5,
    e_saturday = 6,
    e_sunday = 7,
};

enum class en_way
{
    e_walk,
    e_bicycle,
    e_busy,
    e_car,
};
~~~

枚举的作用是尽可能的在代码中标记出所有选择，以明确更准确的含义  
在 main.cpp 文件中，枚举 en_weekday 表示一周内饿所有天数，而且同数字 1~7 进行了标记，这是因为更符合日常习惯，因为枚举默认是从0开始，不标记则是 0~6 这个数字  
en_weekday 枚举实际就是数字 1~7 而已，但是使用枚举名称会给数据赋上一个明确的意义，比如使用数字1，它可能是1块钱，或者1分钟，但使用 e_monday 这个数字1就是表示星期一，而没有其他的歧义，这种准确的表达是有利于使用者的    
让数据含义明确是 **编程规范** 的重要一步  
 
#### 如何选择

en_weekday 和 en_way 的声明方式不一样，en_weekday 没有 class 进行约束，它实际上是一个 int 类型的数据，它可以和 int 类型一样进行加减乘除，在使用时也不需要指定前缀名称，但是这种用法等于全局枚举，需要每一个枚举名称都不能重复，普通枚举可能会污染命名空间    
en_way 不能随意转为 int 类型，它被约定为是一种类型，而不是一种数据，使用 en_way 的枚举值必须通过前缀获取，而且不能与 int 等类型进行转化  
en_way 是强制类型枚举，它是更安全的用法，它可以在不同枚举作用域内声明相同的枚举名称，而普通枚举则不行，推荐新手使用带 class 的强制类型枚举  
使用枚举时，我们通常是很明确使用者是要使用什么类型的，而不是通过遍历之类的间接方式，否则枚举值就失去了意义  
通常枚举是不需要转成整数类型的，如果你需要强转枚举，你应该采用普通枚举，而不是强制类型的枚举，如果你需要强转枚举或者是你的代码设计中其实并不需要枚举  

#### 函数重载
~~~
// 推荐-函数重载-同名函数调用多种类型
std::string to_str_enum(en_way en)
std::string to_str_enum(en_weekday en)

// 不推荐-另起函数名-调用者需要区分不同类型选择对于函数名
std::string to_str_way(en_way en)
std::string to_str_weekday(en_weekday en)
~~~
你可能会疑惑为什么 to_str_enum 函数会有两个，这样不会造成重名吗，实际上只要参数列表不一致就不会造成重名，而是会变成函数重载，函数重载允许函数名相同但参数类型不一致的函数存在，由编译器进行改名，所以他们实际上也是名字不一致的  
函数重载可以让调用者跟使用模板函数一样，使用同一个函数名对不同类型但相同返回值的函数直接调用，函数重载的使用是相当多的，而且非常频繁，那什么时候适合用函数重载  
当一个函数的功能实现的功能是一样的，返回值是一样的，只有参数是不一样的，但是有需要对不同参数做单独处理，那就使用函数重载，而不是重新起一个函数名称  
从对 en_way en_weekday 两个枚举类型的字符串转化可以看出，他们的需求是一样的，只是转为字符串而已，但是不同类型转的字符串又不一样，所以需要使用函数重载    

#### 最优分支

前面提到应该优先使用 if 而不是 switch ，但在 main.cpp 文件中，我都在使用 switch 处理枚举值分支  
处理枚举正是 switch 最该使用的地方，因为枚举值很简单且类型很多，而且枚举值分支不会需要多重判断的功能，是最适合使用 switch 指令的地方  

#### 查看枚举值
~~~
MCLOG("查看类型 en_weekday");
for (int i = e_monday; i <= e_sunday; i++)
{
    MCLOG($(i));
}

MCLOG("查看类型 en_way ，需要强转，非常不推荐");
for (int i = static_cast<int>(en_way::e_walk); i <= static_cast<int>(en_way::e_car); i++)
{
    MCLOG($(i));
}
~~~

前面提到过，没有被 class 约束的枚举类型 en_weekday 是 int 类型，所以可以直接使用循环，访问枚举值  
en_way 是被 class 约束的，需要类型强转成 int 才能访问枚举值，实际上被约束之后依旧是 int 类型，只是不提供访问而已，但是我非常不建议强转枚举值  

#### 不要轻易强制转换数据类型

如果你需要强转，你应该使用 static_cast<int>(val) 之类的强转关键字，而是只是使用 (int)val 这种简化写法  
首先是使用 static_cast 是很麻烦的，这会让你在下意识里不希望使用强转，而不是滥用强转，毫无负担的使用强转，当你判断代码是类型错误引发的崩溃，你可以通过查找 static_cast 关键字追踪代码，如果你使用了 (int)val 方式的简化方式，那你可能无从查起  
强转是非常危险的行为，当你真的需要强转一定会迫不得已才使用的，而不是随意使用，如果过多使用强转应该考虑的是代码设计出现了问题  

#### 类型前缀

你总是可以从我的演示代码中看到类似 en_weekday e_monday 带有 en e 等多余的前缀符号，其实这只是我个人的编写习惯，我可以通过这些前缀来快速的识别变量类型，以及更快的代码补全  
你要知道C++的编辑器代码补全通常是很糟糕的，你想查找 weekday 你输入 we 可能会存在非常多可选的补全代码，但是你输入 en_we 这个补全选项会过滤掉相当大的一部分，这也是利好调用者的一种设计  
我不知道你是否认同，但这只是我的个人习惯不管好与坏，但我不建议你模仿，或许你在未来会形成自己独有的习惯


## 编译问题

replace_str_ref 函数被提取到了 format.h 头文件中，并实现了函数分离，你如果无法编译代码，请参考 **你的第二个函数** 文章中提到的编译方式，你需要将 .h .cpp 代码放到对应目录结构，然后修改 CMakeLists.txt 文件，你才能成功编译代码并运行  


## 项目路径
~~~
https://github.com/HellowAmy/mcpp.git
~~~