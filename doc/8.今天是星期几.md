# 今天是星期几


## 打折商品
#### main.cpp
~~~
~~~

#### format.h
~~~
~~~

#### format.cpp
~~~
~~~

#### 打印结果
~~~
~~~

如果你是从第一篇开始观看这个系列的文章的，你学会了如何去编译可执行文件，学会了编写一个拥有完整控制流的程序，学会了如何优雅的管理和组织你的代码，但是你还缺少如何更好的组织数据的能力  
如果你看了上面的代码，你应该也发现了今天带来的新内容有所不同  
在 main.cpp 代码文件上，我描述了在接下来一周内，我可能前往的打折商店，我会记录他们需要的价格以及出现时间和出现方式以免错过，然后我为这个出行准备了一大堆来进行处理  
在编程中大部分时间都是在处理各种各样的数据，他们可能是简单的或者是复杂的一堆数据，我们需要的就是要处理这一堆堆的数据，那首先第一步就是要创建自己的一堆数据，以及如何使用他们  

#### 一堆数据
~~~
struct shopping_check
{
    int money = 0;
    int time = 0;
    int distance = 0;
    en_way way = en_way::e_walk;
    std::string describe;
};
~~~

我们需要去做程序的时候，总是在处理一堆数据，这一堆数据几乎都是对一件事情有着高度关联的，这时候我们需要使用结构体（struct）将他们组装在一起，让他们形成一个整体，好让我们可以更容易的修改或者使用这个结构体内的数据    
我在上面创建了一个 shopping_check 结构体，这个结构体内数据的关联是我要去购物需要注意的事项，我将所有需要提醒我出门前准备的东西都放入到这个结构体内，到时候我将可以通过这个结构体的内容获取到备忘录信息，这个结构体内的数据是高度关联的  
保持数据相关性是 **编程规范** 的重要一步  
结构体的作用就在于此，一个可以放入各种相关数据的类型，然后我们可以通过这个类型获取相关数据，如果你使用结构体，而是将数据使用普遍的变量存储，你将无法知道他们的确切关联，对想使用这些数据的开发者来讲是非常难受的  

#### 请初始化数据

你可以看到在 shopping_check 上，他们的数据 money time 被成为成员变量，这些基本类型都被赋值为 0 ，这是一个好习惯，你会发现我在创建变量时，几乎都会手动去赋值，这一步叫初始化变量，这样做会让变量总是可以确认开始的值是 0 这个数字  
初始化变量是 **编程规范** 的重要一步  
结构体和变量是一样的，我们在创建他们时给他们的成员变量创建一个默认值，这是一个好习惯    
你会发现 string 我几乎不会初始化，那是因为 string 是一个类，而不是基本类型，他们本身会自己进行初始化  

#### 创建和使用数据
~~~
// 创建结构体，将数字赋值给成员
shopping_check ct;
ct.money = 15;
ct.time = 18;

// 使用结构体，将成员数据赋值给变量
shopping_check ct;
int money = ct.money;
int time = ct.time;
~~~

结构体的创建和使用都会简单，只需要在生命结构体时使用 . 操作符，他们编辑器就会提示你有什么成员可以选择  
你可以给成员赋值，或者将成员的内容赋值给其他变量，请赋值号（= 等号）的和成员的位置关系，这是新手需要注意的地方  
结构体可以看成是一个复杂类型的变量，是多个类型的结合体，他的使用其实和普通类型的变量没什么不同，你使用结构体时只需要指定你想使用的具体成员名称就可以了  
你要记住，结构体其实不复杂，只是将几个类型黏在一起的二进制而已  

#### 结构体的本质
~~~
// 打印结构体二进制
struct two_int
{
    char n1 = 1;
    char n2 = 2;
    char n4 = 4;
    char n8 = 8;
};
two_int ct;
int ibyte;
std::memcpy(&ibyte, &ct, sizeof(ibyte));
std::string bit_ct = print_byte<int>(ibyte);
MCLOG($(bit_ct));

// 打印
[bit_ct: 00001000000001000000001000000001]

/*
通过分析得出two_int内容和 n1 n2 的连续数据结构一致
    通过1248法分析结构体二进制内容
        00001000 00000100 00000010 00000001
        8        4        2        1
*/
~~~ 

通过上面的结构体二进制代码分析之后，发现存着 4char 的结构体，只是将 4char 的内容合并为一块整理，内存大小不变  
你会发现原来复杂的结构体数据原来也只是简单的内存组合而已，也就是说实际上结构体的成员数据获取和使用，也只是通过地址偏移对一整块内存的指定区域进行访问  
结构体没什么复杂的，要记住在C++中一切数据都只是二进制内存而已  

#### R表达式
~~~
void print_shopping_check(en_weekday en)
{
    // 字符串R表达式，所见所得，无需使用 \n 进行换行
    // R表达时会无视字符串的任何转换格式
    std::string str =
        R"(
不要忘记 {0} 的打折活动：{1} 
带钱：{2}块，时间：{3}点，距离：{4}公里，交通：{5}
)";
}
~~~

你发现 print_shopping_check 函数中的字符串赋值很难看了吗，它居然没有缩进结构，看起来和平时写的代码的缩进结构完全不一样，居然是顶着第一行写的  
这个字符串被 R"()" 给包裹起来，这种写法叫 R表达式 ，你要是注意看打印结果就会发现，这段字符串的打印是有换行的，但是代码没有出现 \n 等换行符，这是因为R表达式会以肉眼可见的方式转化为字符串，更符合人的文本编写，R表达式适合进行大量多行复杂本文的编辑，因为它是所见既所得的，且不需要处理转义字符    
转义字符是指和指定格式一致的文本不会被打印 ，如果我需要打印 "\n" 这个文本，我需要在代码上写  "\\n" 才行，否则打印结果是空格，而不是 "\n" 这两个字符，具体有那些转义字符你需要自行学习  
我会很不优雅的顶格写是因为打印需要顶格输出，如果我不顶格，而是在R表达式内部缩进，那打印的内容也会缩进，这是R表达式的特点，请记住这一点区别  


## 枚举类型
#### 枚举所有可能
~~~
enum en_weekday
{
    e_monday = 1,
    e_tuesday = 2,
    e_wednesday = 3,
    e_thursday = 4,
    e_friday = 5,
    e_saturday = 6,
    e_sunday = 7,
};

enum class en_way
{
    e_walk,
    e_bicycle,
    e_busy,
    e_car,
};
~~~

枚举的作用是尽可能的在代码中标记出所有选择，以明确更准确的含义  
在 main.cpp 文件中，枚举 en_weekday 表示一周内饿所有天数，而且同数字 1~7 进行了标记，这是因为更符合日常习惯，因为枚举默认是从0开始，不标记则是 0~6 这个数字  
en_weekday 枚举实际就是数字 1~7 而已，但是使用枚举名称会给数据赋上一个明确的意义，比如使用数字1，它可能是1块钱，或者1分钟，但使用 e_monday 这个数字1就是表示星期一，而没有其他的歧义，这种准确的表达是有利于使用者的    
让数据含义明确是 **编程规范** 的重要一步  
 
#### 如何选择

en_weekday 和 en_way 的声明方式不一样，en_weekday 没有 class 进行约束，它实际上是一个 int 类型的数据，它可以和 int 类型一样进行加减乘除，在使用时也不需要指定前缀名称，但是这种用法等于全局枚举，需要每一个枚举名称都不能重复，普通枚举可能会污染命名空间    
en_way 不能随意转为 int 类型，它被约定为是一种类型，而不是一种数据，使用 en_way 的枚举值必须通过前缀获取，而且不能与 int 等类型进行转化  
en_way 是强制类型枚举，它是更安全的用法，它可以在不同枚举作用域内声明相同的枚举名称，而普通枚举则不行，推荐新手使用带 class 的强制类型枚举  
使用枚举时，我们通常是很明确使用者是要使用什么类型的，而不是通过遍历之类的间接方式，否则枚举值就失去了意义  
通常枚举是不需要转成整数类型的，如果你需要强转枚举，你应该采用普通枚举，而不是强制类型的枚举，如果你需要强转枚举或者是你的代码设计中其实并不需要枚举  

#### 函数重载
~~~
// 推荐-函数重载-同名函数调用多种类型
std::string to_str_enum(en_way en)
std::string to_str_enum(en_weekday en)

// 不推荐-另起函数名-调用者需要区分不同类型选择对于函数名
std::string to_str_way(en_way en)
std::string to_str_weekday(en_weekday en)
~~~
你可能会疑惑为什么 to_str_enum 函数会有两个，这样不会造成重名吗，实际上只要参数列表不一致就不会造成重名，而是会变成函数重载，函数重载允许函数名相同但参数类型不一致的函数存在，由编译器进行改名，所以他们实际上也是名字不一致的  
函数重载可以让调用者跟使用模板函数一样，使用同一个函数名对不同类型但相同返回值的函数直接调用，函数重载的使用是相当多的，而且非常频繁，那什么时候适合用函数重载  
当一个函数的功能实现的功能是一样的，返回值是一样的，只有参数是不一样的，但是有需要对不同参数做单独处理，那就使用函数重载，而不是重新起一个函数名称  
从对 en_way en_weekday 两个枚举类型的字符串转化可以看出，他们的需求是一样的，只是转为字符串而已，但是不同类型转的字符串又不一样，所以需要使用函数重载    

#### 最优分支

前面提到应该优先使用 if 而不是 switch ，但在 main.cpp 文件中，我都在使用 switch 处理枚举值分支  
处理枚举正是 switch 最该使用的地方，因为枚举值很简单且类型很多，而且枚举值分支不会需要多重判断的功能，是最适合使用 switch 指令的地方  

#### 查看枚举值
~~~
MCLOG("查看类型 en_weekday");
for (int i = e_monday; i <= e_sunday; i++)
{
    MCLOG($(i));
}

MCLOG("查看类型 en_way ，需要强转，非常不推荐");
for (int i = static_cast<int>(en_way::e_walk); i <= static_cast<int>(en_way::e_car); i++)
{
    MCLOG($(i));
}
~~~

前面提到过，没有被 class 约束的枚举类型 en_weekday 是 int 类型，所以可以直接使用循环，访问枚举值  
en_way 是被 class 约束的，需要类型强转成 int 才能访问枚举值，实际上被约束之后依旧是 int 类型，只是不提供访问而已，但是我非常不建议强转枚举值  

#### 不要轻易强制转换数据类型

如果你需要强转，你应该使用 static_cast<int>(val) 之类的强转关键字，而是只是使用 (int)val 这种简化写法  
首先是使用 static_cast 是很麻烦的，这会让你在下意识里不希望使用强转，而不是滥用强转，毫无负担的使用强转，当你判断代码是类型错误引发的崩溃，你可以通过查找 static_cast 关键字追踪代码，如果你使用了 (int)val 方式的简化方式，那你可能无从查起  
强转是非常危险的行为，当你真的需要强转一定会迫不得已才使用的，而不是随意使用，如果过多使用强转应该考虑的是代码设计出现了问题  

#### 类型前缀

你总是可以从我的演示代码中看到类似 en_weekday e_monday 带有 en e 等多余的前缀符号，其实这只是我个人的编写习惯，我可以通过这些前缀来快速的识别变量类型，以及更快的代码补全  
你要知道C++的编辑器代码补全通常是很糟糕的，你想查找 weekday 你输入 we 可能会存在非常多可选的补全代码，但是你输入 en_we 这个补全选项会过滤掉相当大的一部分，这也是利好调用者的一种设计  
我不知道你是否认同，但这只是我的个人习惯不管好与坏，但我不建议你模仿，或许你在未来会形成自己独有的习惯


## 编译问题

replace_str_ref 函数被提取到了 format.h 头文件中，并实现了函数分离，你如果无法编译代码，请参考 **你的第二个函数** 文章中提到的编译方式，你需要将 .h .cpp 代码放到对应目录结构，然后修改 CMakeLists.txt 文件，你才能成功编译代码并运行  














## 项目路径
~~~
https://github.com/HellowAmy/mcpp.git
~~~