# 重写最速公式


## 重写游戏
#### main.cpp
~~~
#include <iostream>
#include <map>
#include <vector>
#include <thread>
#include <chrono>
#include <algorithm>
#include <random>
#include <memory>
#include <functional>
#include <atomic>

#include "mclog.h"
#include "rand_int.h"
#include "replace_fix.h"

// 输入状态
enum class en_mode_input
{
    e_game,
    e_quit,
    e_back,
};

// 游戏状态
enum class en_mode_game
{
    e_win,
    e_failed,
    e_next,
};

// 记录输入状态，如果为游戏输入需要数字
struct input_ctx
{
    en_mode_input status = en_mode_input::e_game;
    int value = 0;
};

// 接收输入，统一获取输入状态
class recv_input
{
public:
    recv_input()
    {
        // 动态插入输入状态，提供定制输入状态
        _mp_opt_tab["quit"] = en_mode_input::e_quit;
        _mp_opt_tab["back"] = en_mode_input::e_back;
    }

    // 处理输入字符
    input_ctx get_input()
    {
        // 接收输入，直到符合需求后退出
        input_ctx ret;
        std::string buff;
        while (true)
        {
            std::cin >> buff;

            // 找到指定输入后返回
            auto it = _mp_opt_tab.find(buff);
            if (it != _mp_opt_tab.end())
            {
                ret.status = it->second;
                return ret;
            }

            // 这里表示启动游戏后的输入，需要保存为数字
            try
            {
                ret.value = std::stoi(buff);
                return ret;
            }
            catch (...)
            {
                print_input_tips();
            }
        }
    }

    // 更方便的状态判断函数
    bool is_game(const input_ctx &input)
    {
        return input.status == en_mode_input::e_game;
    }
    bool is_quit(const input_ctx &input)
    {
        return input.status == en_mode_input::e_quit;
    }

private:
    // 提示可输入内容
    void print_input_tips()
    {
        std::string opt;
        for (auto &a : _mp_opt_tab)
        {
            opt += "|:" + a.first + "  ";
        }
        std::string str = "输入错误，可选的值有\n{}";
        str = replace_fix(str)(opt);
        std::cout << str << std::endl;
    }

private:
    // 保存输入状态，使用 map 可动态插入新状态，方便扩展
    std::map<std::string, en_mode_input> _mp_opt_tab;
};

// 一个批量生产不同计算规则的游戏基类
// 这个类规定了运算游戏的流程，但是不会进行具体的运算
class game_flow
{
public:
    // 子类需要提供的运行数据
    struct data
    {
        int total = 0;
        int residue = 0;
        en_mode_game status = en_mode_game::e_next;
        std::vector<int> rule_num;
    };

public:
    // 开始游戏接口
    input_ctx start_game()
    {
        // 记录游戏开始
        using namespace std::chrono;
        _game_time = 0;
        auto begin_time = steady_clock::now();

        // 获取子类提供的数据，打印提示后开始
        data d = get_data();
        print_describe(d);
        for (int i = 0; i < d.rule_num.size(); i++)
        {
            // 判断是否需要终止游戏
            if (d.status != en_mode_game::e_next)
            {
                break;
            }

            // 获取随机数，打印本次输入提示
            int rule_num = d.rule_num[i];
            print_tips(i, rule_num, d);

            // 获取用户输入，查看是退出还是回答了问题
            input_ctx ctx = _input.get_input();
            if (_input.is_game(ctx) == false)
            {
                print_back(i, d);
                return ctx;
            }

            // 调用子类的 calc_rule 计算规则
            // 计算是否返回的结果是否都导致游戏失败
            // update_status 更新状态来决定是否失败
            int input_num = ctx.value;
            int sum = calc_rule(rule_num, input_num);
            int cur_residue = d.residue;
            int diff = d.total - sum;
            d.residue -= std::abs(diff);
            update_status(d, false);

            // 显示计算后余量
            std::string str = "residue: {} = {} - {} >> {} = {} - |{}|\n";
            str = replace_fix(str)(diff, d.total, sum, d.residue, cur_residue, diff);
            std::cout << str << std::endl;
        }

        // 游戏结束，更新胜利状态并打印提示语
        // input_ctx() 默认状态是游戏正在进行
        update_status(d, true);
        print_game_over(d);

        // 计算游戏时间，并记录最快时间
        auto end_time = steady_clock::now();
        _game_time = duration_cast<seconds>(end_time - begin_time).count();
        if (_fast_game_time == 0 || _game_time < _fast_game_time)
        {
            if (d.status == en_mode_game::e_win)
            {
                _fast_game_time = _game_time;
            }
        }
        return input_ctx();
    }

    // 获取完成游戏的时间
    size_t finish_game_time_sec()
    {
        return _game_time;
    }

    // 最快通过时间
    size_t fast_game_time_sec()
    {
        return _fast_game_time;
    }

    // 游戏名称
    virtual std::string game_name() = 0;

protected:
    // 不同游戏进入时的首次描述
    virtual void print_describe(const data &d) = 0;

    // 不同游戏的单次运行提示游戏输入的提示
    virtual void print_tips(int count, int num, const data &d) = 0;

    // 子类的计算结果
    virtual int calc_rule(int a, int b) = 0;

    // 子类需要提供的运行数据
    virtual data get_data() = 0;

private:
    // 根据计算余年更新状态
    void update_status(data &d, bool end)
    {
        if (d.residue <= 0)
        {
            d.status = en_mode_game::e_failed;
        }
        else if (d.residue > 0 && end == false)
        {
            d.status = en_mode_game::e_next;
        }
        else if (d.residue > 0 && end)
        {
            d.status = en_mode_game::e_win;
        }
    }

    // 游戏结束打印
    void print_game_over(const data &d)
    {
        std::string game_ret = "游戏胜利";
        if (d.status == en_mode_game::e_failed)
        {
            game_ret = "游戏失败";
        }

        std::string str = "{} total = {} residue = {}";
        str = replace_fix(str)(game_ret, d.total, d.residue);
        std::cout << str << std::endl;
    }

    // 临时退出时打印
    void print_back(int count, const data &d)
    {
        std::string str = "选择返回菜单，运行到 {} 次，当前结果 total = {} residue = {}";
        str = replace_fix(str)(count, d.total, d.residue);
        std::cout << str << std::endl;
    }

private:
    // 用户输入管理，用于统一处理输入状态
    recv_input _input;

    // 记录通过时间和最快通过时间
    size_t _game_time = 0;
    size_t _fast_game_time = 0;
};

// 乘法运算
// 继承最速公式游戏流，实现子类接口完成游戏，多态效果
class game_mul : public game_flow
{
protected:
    // 下方都为重写实现父类的虚函数
    void print_describe(const data &d) override
    {
        std::string str = "乘法计算，游戏规则如下\n"
                          "  存在公式 sum = a * b , 会用 total - sum = diff , \n"
                          "  差值累加 residue = residue - diff，当 residue <= 0 时失败\n"
                          "  我会随机提供 a ，你需要输入 b ，请让 sum 尽可能接近 total\n"
                          "  当前 total = {} residue = {} 共进行 {} 次\n";
        str = replace_fix(str)(d.total, d.residue, d.rule_num.size());
        std::cout << str << std::endl;
    }
    void print_tips(int count, int num, const data &d) override
    {
        std::string str = "当前为 {} 次，余量为 residue = {} \n"
                          "公式 {} = {} * b ，请输入 b = ";
        str = replace_fix(str)(count + 1, d.residue, d.total, num);
        std::cout << str << std::endl;
    }
    int calc_rule(int a, int b) override
    {
        int sum = a * b;
        std::string str = "{} = {} * {}";
        str = replace_fix(str)(sum, a, b);
        std::cout << str << std::endl;
        return sum;
    }
    data get_data() override
    {
        data d;
        d.total = 200;
        d.residue = 100;

        // 提供随机数为计算元素，让玩家更难计算
        rand_int rand(2, 40);
        for (int i = 0; i < 3; i++)
        {
            d.rule_num.push_back(rand.value());
        }
        return d;
    }
    std::string game_name() override
    {
        return "乘法计算";
    }
};

// 指数运算
class game_exp : public game_flow
{
protected:
    void print_describe(const data &d) override
    {
        std::string str = "指数计算，游戏规则如下\n"
                          "  存在公式 sum = a ^ b , 会用 total - sum = diff , \n"
                          "  差值累加 residue = residue - diff，当 residue <= 0 时失败\n"
                          "  我会随机提供 a ，你需要输入 b ，请让 sum 尽可能接近 total\n"
                          "  当前 total = {} residue = {} 共进行 {} 次\n";
        str = replace_fix(str)(d.total, d.residue, d.rule_num.size());
        std::cout << str << std::endl;
    }
    void print_tips(int count, int num, const data &d) override
    {
        std::string str = "当前为 {} 次，余量为 residue = {} \n"
                          "公式 {} = {} ^ b ，请输入 b = ";
        str = replace_fix(str)(count + 1, d.residue, d.total, num);
        std::cout << str << std::endl;
    }
    int calc_rule(int a, int b) override
    {
        int sum = std::pow(a, b);
        std::string str = "{} = {} ^ {}";
        str = replace_fix(str)(sum, a, b);
        std::cout << str << std::endl;
        return sum;
    }
    data get_data() override
    {
        data d;
        d.total = 1000;
        d.residue = 500;

        rand_int rand(3, 7);
        for (int i = 0; i < 3; i++)
        {
            d.rule_num.push_back(rand.value());
        }
        return d;
    }
    std::string game_name() override
    {
        return "指数计算";
    }
};

// 最速公式游戏启动接口
class fast_game
{
public:
    fast_game()
    {
        // 使用 shared_ptr 智能指针管理线程，这里提供了创建和销毁方式
        // new std::thread(&fast_game::work_countdown_th, this) 创建一个线程并运行
        // th->join(); 回调是用于销毁线程
        _th_countdown = std::shared_ptr<std::thread>(
            new std::thread(&fast_game::work_countdown_th, this),
            [](std::thread *th)
            { th->join(); });
    }

    // 倒计时线程
    void work_countdown_th()
    {
        _countdown = -1;
        while (_run)
        {
            // 写入倒计时内容，使用 flush 函数刷新缓冲区
            if (_countdown >= 0)
            {
                std::cout << "\033[s";
                std::cout << "\033[3A";
                std::cout << "\r" << "countdown: " << _countdown;
                std::cout << "\033[u";
                std::flush(std::cout);
                _countdown++;
            }
            std::this_thread::sleep_for(std::chrono::seconds(1));
        }
    }

    // 启动入口
    void run()
    {
        while (_run)
        {
            // 显示菜单并获取输入
            print_menu();
            input_ctx input = _input.get_input();

            // 判断是否开始游戏
            if (_input.is_game(input))
            {
                // 找到指定游戏并运行
                game_flow *game = game_type(input.value);
                if (game)
                {
                    start_game();
                    input = game->start_game();
                    end_end();

                    // 打印游戏时间
                    size_t sec = game->finish_game_time_sec();
                    if (sec > 0)
                    {
                        int fast_time = game->fast_game_time_sec();

                        std::string str = "本次游戏时间为: {}秒\n"
                                          "最快记录为: {}秒\n";
                        str = replace_fix(str)(sec, fast_time);
                        std::cout << str << std::endl;
                    }
                }
            }

            // 判断是否退出，包括游戏中的状态返回
            if (_input.is_quit(input))
            {
                print_quit();
                _run = false;
            }
        }
    }

    // 安装游戏类型
    void install_game(std::shared_ptr<game_flow> game)
    {
        _mp_game[_mp_game.size() + 1] = game;
    }

private:
    // 显示菜单
    void print_menu()
    {
        std::string opt;
        for (auto &a : _mp_game)
        {
            opt += replace_fix("{}.{} \n")(a.first, a.second->game_name());
        }
        std::string str = "\n欢迎来到最速公式，可选择以下游戏\n{}";
        str = replace_fix(str)(opt);
        std::cout << str << std::endl;
    }

    // 结束游戏
    void print_quit()
    {
        std::cout << "欢迎下次游玩" << std::endl;
    }

    // 查找到指定游戏后返回
    game_flow *game_type(int index)
    {
        auto it = _mp_game.find(index);
        if (it != _mp_game.end())
        {
            return it->second.get();
        }
        return nullptr;
    }

    // 开始游戏时初始化参数
    void start_game()
    {
        _countdown = 0;
    }

    // 结束游戏时回收
    void end_end()
    {
        _countdown = -1;
    }

private:
    bool _run = true;
    recv_input _input;

    // 使用 map 容器可以动态的扩展选项
    // 存放启动游戏的指针，使用智能指针管理内存
    std::map<int, std::shared_ptr<game_flow>> _mp_game;

    // 原子变量，保证多线程修改数据准确
    std::atomic<int> _countdown;

    // 倒计时线程，在构造函数中初始化
    std::shared_ptr<std::thread> _th_countdown = nullptr;
};

int main(int argc, char **argv)
{
    fast_game game;

    // 动态添加游戏
    // 智能指针管理权会将转移到 fast_game 中的 map 容器中
    game.install_game(std::make_shared<game_mul>());
    game.install_game(std::make_shared<game_exp>());

    game.run();

    return 0;
}

~~~

#### replace_fix.h
~~~
#ifndef REPLACE_FIX_H
#define REPLACE_FIX_H

#include <string>

// 替换字符串，只替换固定形式的字符串，接收多类型，并自动换行成字符串
struct replace_fix
{
    replace_fix(const std::string &org) : _org(org) {}

    // 自动将其他类型转为字符串
    template <typename T>
    std::string to_str(const T &val)
    {
        return std::to_string(val);
    }

    std::string to_str(const std::string &str)
    {
        return str;
    }

    std::string to_str(const char *str)
    {
        return str;
    }

    // 替换函数
    std::string replace_flag(const std::string &org, const std::string &str)
    {
        std::string ret;
        size_t follow = 0;
        size_t go = org.find(_flag);
        if (go == std::string::npos)
        {
            return ret;
        }
        ret += std::string(org.begin() + follow, org.begin() + go);
        ret += str;
        go += _flag.size();
        follow = go;
        ret += std::string(org.begin() + follow, org.end());
        return ret;
    }

    // 递归展开
    std::string replace()
    {
        return _org;
    }

    template <typename T,typename... Targ>
    std::string replace(T value, Targ... arg)
    {
        std::string str = to_str(value);
        _org = replace_flag(_org, str);
        return replace(arg...);
    }

    template <typename... Targ>
    std::string operator()(Targ... arg)
    {
        return replace(arg...);
    }

    std::string _org;
    std::string _flag = "{}";
};

#endif // REPLACE_FIX_H
~~~

#### 打印结果
~~~
欢迎来到最速公式，可选择以下游戏
1.乘法计算 
2.指数计算 

2
指数计算，游戏规则如下
  存在公式 sum = a ^ b , 会用 total - sum = diff , 
  差值累加 residue = residue - diff，当 residue <= 0 时失败
  我会随机提供 a ，你需要输入 b ，请让 sum 尽可能接近 total
  当前 total = 1000 residue = 500 共进行 3 次
countdown: 27
当前为 1 次，余量为 residue = 500 
公式 1000 = 6 ^ b ，请输入 b = 
4
1296 = 6 ^ 4
residue: -296 = 1000 - 1296 >> 204 = 500 - |-296|
countdown: 63
当前为 2 次，余量为 residue = 204 
公式 1000 = 3 ^ b ，请输入 b = 
5
243 = 3 ^ 5
residue: 757 = 1000 - 243 >> -553 = 204 - |757|

游戏失败 total = 1000 residue = -553
本次游戏时间为: 64秒
最快记录为: 0秒


欢迎来到最速公式，可选择以下游戏
1.乘法计算 
2.指数计算
~~~

如果你看过 玩一个小游戏 的那一篇文章，你会发现那时间编写的代码可以说是束手束脚，但到了这里，C++的所有基础语法几乎都已经学完了，那是时候以更好的方式对 最速公式 小游戏的代码进行重写了，这一次采用的是面向对象的方式实现    
代码总是需要不断改进的，当你有更好的想法的时候，就可以小规模的优化曾经的代码  

#### 定制状态

在 main.cpp 中你应该可以看到开头的 en_mode_input en_mode_game 枚举   en_mode_input 描述了游戏玩家输入时是在游戏中输入数字还是要在菜单中转移  
en_mode_game 描述了一个游戏正在进行时，当前状态是正在进行还是已经结束  
我们可以根据这种状态来对程序的流程进行控制  
其中 input_ctx 类型放置了用户的输入结果，以及数字，这些状态都由 recv_input 进行处理，这个类统一处理用户的输入  
你会看到 recv_input 类会在 game_flow 和 fast_game 两个类中都有出现，这是它提供了在游戏中和在菜单中的两种输入状态  

#### 同质化游戏流程
~~~
// 统一流程
class game_flow  {}

// 统一描述
class game_base : public game_flow {}

// 提供公式
class game_mul : public game_base {}
class game_exp : public game_base {}
~~~

最速公式 游戏主要就是两个数进行运算，然后不同模式选择不一样的运算规则，如加减乘除等，他们的相似度都非常高，所以他们是值得抽离出来的  
在 main.cpp 中 game_flow 就是抽离出相同流程的代码，对一些重复的步骤进行抽离，比如菜单描述，每部运算描述，计算结果差值累加，计算最快时间，判断游戏胜负等功能  
game_flow 是抽象类，它提供了一系列必须要子类实现的虚函数，只要子类实现这些虚函数就可以定制出不同算法的套壳游戏  
game_mul game_exp 两个类都是 game_flow 的子类实现，但是你可以看出其他们的代码重复度依旧很高，如果你原因，还可以在抽离出一层，如上面的 game_base 一样的结构去进一步简化代码  
当然 game_base 是很必要的，如果你全部都写到 game_flow 中而不提供中间层，你的整个继承流程会得到简化，但是先修改时却会变得复杂  

#### 状态转移

如果你看过第一版的 最速公式 代码，你会发现我很喜欢制定一些看起来和枚举一样不变的值，来确定他们的状态，其实这种判断枚举状态的操作是非常常用的方法  
你只需要在不同的状态下切换枚举值，然后通过简单逻辑判断，就可以确认整个程序的运行流程，这种方式相比与直接使用 if else 去判断每一个分支要好的多，如果你已经接触到了设计模式，那这种类似的写法可能会称为状态机     
你可以看到，我在 recv_input 输入类就已经确认了所有的状态输入，并决定了具体的状态，在使用时就可以直接使用这些状态，比如你知道游戏正在进行，或者返回菜单，退出游戏之类的，都是在输入时就已经确认好了，如果你选择在每一地方都自己处理输入，那你可能要处理这些重复值  
你是否会觉得 recv_input 类被两个地方使用，但是他们每一次都不能完全使用这个输入类返回的所有状态，其实这是对的，应该从 recv_input 分出一些子类对不同情况的输入进行特殊处理才是一个好的选择，而不是先现在一样使用同一个 recv_input 类处理菜单和游戏中，这两个完全不一样的输入场景，因为他们的状态转移是有差别的    

#### 动态安装

你可以看到 fast_game 是一个游戏启动器，它本身只提供游戏菜单选择，而且本身是没有内置选择的，你需要动态的添加游戏到 _mp_game 容器中  
这种方法可以然你更灵活的添加新游戏，如果你在 fast_game 中使用 switch 的方式将选择绑定到 fast_game 类的话，你需要添加新游戏就需要改动 fast_game 的代码，这是不好的行为  
不改动代码而可以添加新功能，是一种动态扩展，这种动态扩展是十分方便调用者的，因为当调用者需要添加新功能时只需要调用 install_game 函数，而不需要阅读 fast_game 类的具体代码   
提供动态扩展是 **编程规范** 的重要一步  
动态扩展是面向对象的理念，比如多态就是这种思想的体现，比如在 最速公式 中你不需要更改 game_flow 原有的逻辑就可以添加 game_mul game_exp 等不同功能，这就是一种动态扩展

#### 生命周期转移
~~~
// 接管生命周期，复制，安全
void install_game(std::shared_ptr<game_flow> game);

// 不接管生命周期，引用，const T& 形式，不安全，可能崩溃
void install_game(const std::shared_ptr<game_flow> &game);
~~~

当你需要安装新游戏时调用 install_game 函数，需要传入 std::make_shared 的智能指针，这里需要注意的是，你是否需要全权接管这个智能指针的生命周期，如果你接管了，你会成为最后的释放者，如果你不接管则可能智能指针指向的数据被释放数据为空，执行会崩溃  
你需要接管时，函数变量需要复制，你不接管时，函数变量需要传入引用，我这里使用的是接管的形式，所以可以在调用时使用匿名变量的方式，在一行内写下  
使用智能指针时，我推荐你接管生命周期，但是你需要知道的是传入的数据是否是一次性的，如果是一次性的则不需要接管，因为用完了就丢弃了  
需要注意的是，你需要考虑数据的生命周期是否需要长时间存在，如果是一次性临时数据不需要长时间保持，但是你却保存下这些临时数据，会出现类似内存泄露的问题，因为那些临时数据你保持下来不使用也不释放，依旧会占据空间，然后逐步侵蚀系统内存   

#### 容器内的指针

~~~
std::map<int, std::shared_ptr<game_flow>> _mp_game;
auto it = _mp_game.find(index);

// 执行 game_flow 类的 game_name 函数
it->second->game_name();

// 获取
std::shared_ptr<game_flow> sp = it->second；
~~~

如果你发现不是很能理解 fast_game 类中 game_type 函数返回值为什么是 game_flow 指针，那可能你需要参考上面的代码  
map 容器的迭代器 it 中的 first second 分别对应 map 中的 key value 他们返回的类型是完全一样的，如果你在 map 中存了指针当然可以直接通过迭代器去获取或者执行他们  

#### 多线程

如果你运行了这份代码，你会发现进行游戏时有一个倒计时在提醒你过去了多少时间，而这个倒计时在跳动时并不会影响到你输入内容，因为这个倒计时是运行在子线程上的  
在 fast_game 启动器中有 std::thread 类型的智能指针，这就是多线程的启动，它会单独运行 work_countdown_th 函数，并在函数中每隔一秒打印时间  
你会发现 _countdown 变量不是普通的 int 而是 std::atomic\<int\> 这是一种原子类型，它能保证多线程下修改数据不会变形  
这篇文章我没打算深入多线程问题，多线程内容会在后续文章中提到   

#### 字符替换优化

你会看到我现在使用的是全新的 replace_fix 类，它只会对字符串的 {} 符号进行替换，而且是顺序替换的，但是它在使用上更加便捷，而且可以将其他内容转为字符串，是一个更方便的选择   
当然我不会分析这一段代码，因为它是 replace_args 类和 replace_str_ref 函数的结合体，但是需要提醒你的是，这个类的处理速度依旧很慢仅在测试可用  


## 项目路径
~~~
https://github.com/HellowAmy/mcpp.git
~~~