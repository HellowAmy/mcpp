# 重写最速公式


## 重写游戏
#### main.cpp
~~~
~~~

#### replace_fix.h
~~~

~~~

#### 打印结果
~~~
~~~

如果你看过 玩一个小游戏 的那一篇文章，你会发现那时间编写的代码可以说是束手束脚，但到了这里，C++的所有基础语法几乎都已经学完了，那是时候以更好的方式对 最速公式 小游戏的代码进行重写了，这一次采用的是面向对象的方式实现    
代码总是需要不断改进的，当你有更好的想法的时候，就可以小规模的优化曾经的代码  

#### 定制状态

在 main.cpp 中你应该可以看到开头的 en_mode_input en_mode_game 枚举   en_mode_input 描述了游戏玩家输入时是在游戏中输入数字还是要在菜单中转移  
en_mode_game 描述了一个游戏正在进行时，当前状态是正在进行还是已经结束  
我们可以根据这种状态来对程序的流程进行控制  
其中 input_ctx 类型放置了用户的输入结果，以及数字，这些状态都由 recv_input 进行处理，这个类统一处理用户的输入  
你会看到 recv_input 类会在 game_flow 和 fast_game 两个类中都有出现，这是它提供了在游戏中和在菜单中的两种输入状态  

#### 同质化游戏流程
~~~
// 统一流程
class game_flow  {}

// 统一描述
class game_base : public game_flow {}

// 提供公式
class game_mul : public game_base {}
class game_exp : public game_base {}
~~~

最速公式 游戏主要就是两个数进行运算，然后不同模式选择不一样的运算规则，如加减乘除等，他们的相似度都非常高，所以他们是值得抽离出来的  
在 main.cpp 中 game_flow 就是抽离出相同流程的代码，对一些重复的步骤进行抽离，比如菜单描述，每部运算描述，计算结果差值累加，计算最快时间，判断游戏胜负等功能  
game_flow 是抽象类，它提供了一系列必须要子类实现的虚函数，只要子类实现这些虚函数就可以定制出不同算法的套壳游戏  
game_mul game_exp 两个类都是 game_flow 的子类实现，但是你可以看出其他们的代码重复度依旧很高，如果你原因，还可以在抽离出一层，如上面的 game_base 一样的结构去进一步简化代码  
当然 game_base 是很必要的，如果你全部都写到 game_flow 中而不提供中间层，你的整个继承流程会得到简化，但是先修改时却会变得复杂  

#### 状态转移

#### 动态安装

你可以看到 fast_game 是一个游戏启动器，它本身只提供游戏菜单选择，而且本身是没有内置选择的，你需要动态的添加游戏到 _mp_game 容器中  
这种方法可以然你更灵活的添加新游戏，如果你在 fast_game 中使用 switch 的方式将选择绑定到 fast_game 类的话，你需要添加新游戏就需要改动 fast_game 的代码，这是不好的行为  
不改动代码而可以添加新功能，是一种动态扩展，这种动态扩展是十分方便调用者的，因为当调用者需要添加新功能时只需要调用 install_game 函数，而不需要阅读 fast_game 类的具体代码   
提供动态扩展是 **编程规范** 的重要一步  
动态扩展是面向对象的理念，比如多态就是这种思想的体现，比如在 最速公式 中你不需要更改 game_flow 原有的逻辑就可以添加 game_mul game_exp 等不同功能，这就是一种动态扩展

#### 生命周期转移
~~~
// 接管生命周期，复制，安全
void install_game(std::shared_ptr<game_flow> game);

// 不接管生命周期，引用，const T& 形式，不安全，可能崩溃
void install_game(const std::shared_ptr<game_flow> &game);
~~~

当你需要安装新游戏时调用 install_game 函数，需要传入 std::make_shared 的智能指针，这里需要注意的是，你是否需要全权接管这个智能指针的生命周期，如果你接管了，你会成为最后的释放者，如果你不接管则可能智能指针指向的数据被释放数据为空，执行会崩溃  
你需要接管时，函数变量需要复制，你不接管时，函数变量需要传入引用，我这里使用的是接管的形式，所以可以在调用时使用匿名变量的方式，在一行内写下  
使用智能指针时，我推荐你接管生命周期，但是你需要知道的是传入的数据是否是一次性的，如果是一次性的则不需要接管，因为用完了就丢弃了  
需要注意的是，你需要考虑数据的生命周期是否需要长时间存在，如果是一次性临时数据不需要长时间保持，但是你却保存下这些临时数据，会出现类似内存泄露的问题，因为那些临时数据你保持下来不使用也不释放，依旧会占据空间，然后逐步侵蚀系统内存   

#### 容器内的指针

#### 多线程

如果你运行了这份代码，你会发现进行游戏时有一个倒计时在提醒你过去了多少时间，而这个倒计时在跳动时并不会影响到你输入内容，因为这个倒计时是运行在子线程上的  
在 fast_game 启动器中有 std::thread 类型的智能指针，这就是多线程的启动，它会单独运行 work_countdown_th 函数，并在函数中每隔一秒打印时间  
你会发现 _countdown 变量不是普通的 int 而是 std::atomic\<int\> 这是一种原子类型，它能保证多线程下修改数据不会变形  
这篇文章我没打算深入多线程问题，多线程内容会在后续文章中提到   


## 项目路径
~~~
https://github.com/HellowAmy/mcpp.git
~~~