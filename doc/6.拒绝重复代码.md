# 拒绝重复代码


## 尝试打印所有类型
#### main.cpp
~~~ 
#include <iostream>

#include "mclog.h"
#include "byte_tmp.h"

int main(int argc, char **argv)
{
    // 类型字节长度
    char int08 = '8';
    short int16 = 16;
    int int32 = 32;
    long long int64 = 64;
    float f32 = 32.0;
    double f64 = 64.0;

    // 模板函数调用-自动匹配调用
    std::string bit_int08 = print_byte(int08);
    std::string bit_int16 = print_byte(int16);
    std::string bit_int32 = print_byte(int32);
    std::string bit_int64 = print_byte(int64);
    std::string bit_f32 = print_byte(f32);
    std::string bit_f64 = print_byte(f64);

    // 模板函数调用-指定类型调用
    /*
        std::string bit_int08 = print_byte<char>(int08);
        std::string bit_int16 = print_byte<short>(int16);
        std::string bit_int32 = print_byte<int>(int32);
        std::string bit_int64 = print_byte<long long>(int64);
        std::string bit_f32 = print_byte<float>(f32);
        std::string bit_f64 = print_byte<double>(f64);
    */

    // 假设采用普通函数调用
    /*
        std::string bit_int08 = print_byte_int8<char>(int08);
        std::string bit_int16 = print_byte_int16<short>(int16);
        std::string bit_int32 = print_byte_int32<int>(int32);
        std::string bit_int64 = print_byte_int64<long long>(int64);
        std::string bit_f32 = print_byte_float32<float>(f32);
        std::string bit_f64 = print_byte_float64<double>(f64);
    */

    MCLOG("类型字节长度");
    MCLOG($(int08) $(bit_int08));
    MCLOG($(int16) $(bit_int16));
    MCLOG($(int32) $(bit_int32));
    MCLOG($(int64) $(bit_int64));
    MCLOG($(f32) $(bit_f32));
    MCLOG($(f64) $(bit_f64));

    return 0;
}
~~~

#### byte_tmp.h
~~~ 
#ifndef BYTE_TMP_H
#define BYTE_TMP_H

#include <string>
#include <cstring>
#include <type_traits>

// 整形处理函数
// 模板类 print_byte 支持对更多类型
// 功能与 print_byte_int32 函数类似，可直接参考
template <typename T>
std::string print_byte(T byte, std::true_type)
{
    // 记录二进制字符串
    std::string ret;
    for (size_t i = 0; i < sizeof(T) * 8; i++)
    {
        if (byte & 0x01)
        {
            ret.push_back('1');
        }
        else
        {
            ret.push_back('0');
        }
        byte >>= 1;
    }
    return std::string(ret.rbegin(), ret.rend());
}

// 浮点类型判断函数
template <typename T>
std::string print_byte(T byte, std::false_type)
{
    // 判断浮点类型，如果符合类型拷贝内容到整数类型，并调用上方的 整形处理函数 
    // memcpy 函数可以完整复制浮点数的内存到整形
    if (std::is_same<T, float>::value)
    {
        // 4byte 浮点数
        int ibyte = 0;
        std::memcpy(&ibyte, &byte, sizeof(ibyte));
        return print_byte<int>(ibyte, std::true_type());
    }
    else if (std::is_same<T, double>::value)
    {
        // 8byte 浮点数
        long long ibyte = 0;
        std::memcpy(&ibyte, &byte, sizeof(ibyte));
        return print_byte<long long>(ibyte, std::true_type());
    }

    // 如果不是浮点类型直接返回错误结果
    return "NULL";
}

// 统一调用接口
// std::is_integral<T>() 判断类型，如果是整数返回 true_type 否则返回 false_type
// 通过 is_integral 的返回值可以进入上方的 整形处理函数 或者 浮点类型判断函数 两个函数之一
template <typename T>
std::string print_byte(T byte)
{
    return print_byte<T>(byte, std::is_integral<T>());
}

#endif // BYTE_TMP_H
~~~

#### 打印结果
~~~
类型字节长度 [/home/red/open/github/mcpp/example/06/main.cpp:34]
[int08: 8] [bit_int08: 00111000]  [/home/red/open/github/mcpp/example/06/main.cpp:35]
[int16: 16] [bit_int16: 0000000000010000]  [/home/red/open/github/mcpp/example/06/main.cpp:36]
[int32: 32] [bit_int32: 00000000000000000000000000100000]  [/home/red/open/github/mcpp/example/06/main.cpp:37]
[int64: 64] [bit_int64: 0000000000000000000000000000000000000000000000000000000001000000]  [/home/red/open/github/mcpp/example/06/main.cpp:38]
[f32: 32] [bit_f32: 01000010000000000000000000000000]  [/home/red/open/github/mcpp/example/06/main.cpp:39]
[f64: 64] [bit_f64: 0100000001010000000000000000000000000000000000000000000000000000]  [/home/red/open/github/mcpp/example/06/main.cpp:40]
~~~

在文章 计算压岁钱 中，我们有一个函数 print_byte_int32 这个函数用于打印 int 类型二进制字符串，但这个函数只能打印 int 类型，如果我想打印其他类型就需要为它们单独定义打印函数  

#### 定义这些函数
~~~
// short 类型
std::string print_byte_int16(short byte)
{
    std::string ret;
    for (int i = 0; i < sizeof(byte) * 8; i++)
    {
        if (byte & 0x01) { ret.push_back('1'); }
        else { ret.push_back('0'); }
        byte >>= 1;
    }
    ret = std::string(ret.rbegin(), ret.rend());
    return ret;
}

// int 类型
std::string print_byte_int32(int byte)
{
    std::string ret;
    for (int i = 0; i < sizeof(byte) * 8; i++)
    {
        if (byte & 0x01) { ret.push_back('1'); }
        else { ret.push_back('0'); }
        byte >>= 1;
    }
    ret = std::string(ret.rbegin(), ret.rend());
    return ret;
}
~~~


如果我要打印 short 类型，我要定义 print_byte_int16 这个函数，它和 print_byte_int32 几乎是一样的，它们的区别只有 short byte 和 int byte 这一处地方不同，仅仅是类型不同而以，但是我却需要为它们单独定制一个函数，我需要写一份声明和一份定义，这样的代码我需要写6份，虽然只需要简单的复制粘贴就好了  
但这种代码是毫无必要的，因为它们是重复的，且功能一致的，我们需要把从重复提取出来，这是必须要做的事情，因为一旦需要改动那就需要改动6份  
使用普通函数做这种重复的事情不仅没有必要，还在使用时非常麻烦，因为你需要根据不同类型从这6个不同的函数选择对于的版本，使用模板函数来编写这些重复代码会有非常好的效果  


## 模板的作用
#### 有规律的统一

我在 main.cpp 文件中写了模板函数与普通函数的调用方式，你可以看的出模板的优势，它可以只使用 print_byte 一个函数去代替 print_byte_int16 print_byte_int32 等普通函数，就是因为那些普通函数不同在实现和调用上都是高度统一的，模板可以消除它们之间微小的差距，达到一种统一的效果  
高度统一，这是我喜欢模板的原因，模板很复杂，但是优雅，如果你想体会这种高度统一的感觉，可以尝试自己用普通函数编写出所有的类型打印函数，完成之后将它们进行比对，你会发现它比现象中更好    
我相信你已经看了 byte_tmp.h 文件中模板函数的实现方式，它可以只用一个函数名去自行生成出不同类型的函数，复制自身正是模板的功能  
模板与宏类似，都是用于复制代码，不同的是模板会根据传入的类型自动复制出相应的类型，而宏是需要全都手动指定   
模板的用途主要就是将不同类型的数据处理放入都相同的逻辑之中，这是模板最主要的功能之一  
不过我今天并不打算讲 print_byte 模板函数的具体实现，模板的运行逻辑需要你去自行研究，在AI时代下，我相信这些细枝末节的技术应该已经不是难题    

#### 模板的类型

模板是一个大类，模板函数只是其中的一个功能，模板类可能才是最常用的东西，但是现在还没有到类的部分  
模板有一个好处就是一旦使用错误会直接在编译时显示，所以也可以用来限制传入类型等来强制使用者的规范  
模板还能通过不同的类型选择不同的调用版本，可以统一调用函数接口，模板能使用随意参数，根据参数执行不同代码    
总之模板的功能是十分强大且高效的，模板的功能很多，模板也需要长时间的学习才能掌握    

#### 不要太夸张

模板很好用，但是我现在并不想和新手分享太多有关模板的知识，因为模板虽然好用但是很负责，而且模板是很难跟踪代码运行规律的，而且代码补全也总是失效，非常不建议新手过多使用，虽然你可以通过AI来生成模板函数，但是一旦出现错误，我相信你很难找到问题   
通过AI生成你可以生成很多模板代码，但是这些代码往往很复杂且不容易看懂，看不懂的代码是很危险的  
所以使用模板的第一原则是简化以存在的重复逻辑的代码，而不是一上来就直接使用模板编写，简单易懂的模板才是好模板  
使用简单模板是 **编程规范** 的重要一步    
过度使用模板也有很多问题，比如让你的代码变得越来越难以看懂，你的代码行为难以调试，出现错误的地方不好定位等等原因，所以模板通常来说并不会被大规模使用，而是使用在功能相对独立的部分  

#### 模板只会声明代码

你可能会疑惑，上一篇文章还说要函数分离，为什么 print_byte 函数却将声明和定义都写在了 .h 文件中  
其实模板是只有声明没有定义，我们编写的模板看上去和普通函数一样有声明有定义  
实际上在 .h 文件中编写的代码类似 MCLOG 宏，它这是声明了有一种通用类型类型的模板代码，等到真正调用函数 print_byte(int32); 时会去声明出 int 这个类型的函数定义  
模板的定义时编译器自己生成的，而不是手动编写的，这一点与普通函数不一样，代码上编写的模板代码永远只是声明，请记住这一点  


## 项目路径
~~~
https://github.com/HellowAmy/mcpp.git
~~~
