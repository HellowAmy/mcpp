# 请移动到头文件


## 头文件分离
#### main.cpp
~~~
#include <iostream>

// 引入自定义头文件
#include "mclog.h"

int main(int argc, char **argv)
{
    // 打印日志
    MCLOG("hello world!")
    
    // 打印带参数格式化日志
    MCLOG($("hello world!") $(argc))
    return 0;
}
~~~

#### mclog.h
~~~
#ifndef MCLOG_H
#define MCLOG_H

// 日志打印
#define MCLOG(value) \
    std::cout << value << " [" << __FILE__ << ":" << __LINE__ << "]" << std::endl;

// 日志参数格式化
#define $(value) \
    "[" #value ": " << value << "] "

#endif // MCLOG_H
~~~

#### 打印结果
~~~
hello world! [/home/red/open/github/mcpp/example/03/main.cpp:9]
["hello world!": hello world!] [argc: 1]  [/home/red/open/github/mcpp/example/03/main.cpp:12]
~~~

相比于第一份标准代码文件，这一次代码简洁了很多，值的注意的是，我们引入 iostream 头文件的同时，还引入了新的头文件 mclog   
引入头文件是为了扩展新功能，而这个 mclog 文件正是第一份标准代码的打印日志宏，MCLOG 这个宏已经从 "main.cpp" 中删除，转移到了 mclog.h 文件中  
打印日志的功能通常是需要在整个项目中运用的，提取到头文件之后，想要使用日志宏的代码文件直接引入 mclog 文件即可使用，提取成为头文件会让代码变得更加简洁  

#### 编写差异
~~~
#include <iostream>
#include "mclog.h"
~~~

mclog 头文件是自己编写的头文件，与系统头文件 iostream 在语法上存在差异，编写错误会编译失败，这是新手需要注意的问题  
它们功能和用法上的不同可以自行研究  

#### 文件命名规范
在提取 MCLOG 宏到 mclog.h 文件时，我们需要注意头文件的命名，通常头文件是根据功能或者函数名进行命名的，而函数名又是根据项目名称进行命名的，可以轻易看出 mclog.h 文件名与 MCLOG 宏有着高度相关性

#### 头文件功能划分
通常一个头文件只划分一部分功能，让文件类型划分与具体功能可以保持高度一致性  
一个头文件应该放入那些功能，如何划分区域是十分主观的，你需要为他们之间的关联找到合理的解释，然后再进行划分  
在这个 mclog.h 文件中，它的职责能与打印日志相关，所以我将 MCLOG 宏放入该文件，让其他代码文件调用该头文件实现日志打印功能  
保持文件功能一致性是 "编程规范" 的重要一步  

#### 日志打印分析
你可能已经发现，一直存在一个符号 \$ 宏，这是一个用于格式化变量的宏，一个可以让你轻松知道传入变量名称的宏定义   
这个宏是不规范的，它没有使用字母，并不遵循一般的命名规则，但确可以简单高效的打印出变量名与对应内容，这是我使用它的原因，我也推荐你去使用  
但是，如果 \$ 宏只有单个字符，一旦遇到同名宏这些代码将彻底崩溃，宏是不能同名的，这就是为什么使用宏时需要谨慎小心，好在目前为止我还没有 \$ 的使用存在什么意外  
\$ 的使用可以让变量的打印变得简单，你可以从等价编码代码中看出，他们所需编写的量差距有多大，这就是使用宏带来的好处  

#### 等价编码
~~~
// 使用 cout
std::cout << "[\"hello world!\": " << "hello world!" << "] "
        << "[argc: " << argc << "] " 
        << " [" << __FILE__ << ":" << __LINE__ << "]" << std::endl;

// 使用 MCLOG
MCLOG($("hello world!") $(argc))

// 输出结果
["hello world!": hello world!] [argc: 2]  [/home/red/open/github/mcpp/example/03/main.cpp:12]
["hello world!": hello world!] [argc: 2]  [/home/red/open/github/mcpp/example/03/main.cpp:15]
~~~


## 编译头文件
#### CMakeLists.txt
~~~
cmake_minimum_required(VERSION 4.0)
project(mcpp LANGUAGES CXX)
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_BUILD_TYPE "Debug")

# 设置源文件
if(ALL OR DIR03)
    set(SRC_FILES
        03/main.cpp
    )
endif()

# 包含头文件目录
include_directories(${CMAKE_SOURCE_DIR}/common)

add_executable(${CMAKE_PROJECT_NAME} ${SRC_FILES})
~~~

#### 项目结构
~~~
.
├── 03
│   ├── build
│   │   └── mcpp
│   └── main.cpp
├── common
│   └── mclog.h
├── CMakeLists.txt
└── run.sh
~~~

将 MCLOG 剥离到 mclog.h 之后，我们得到了一个头文件，因为后续我们可能还会剥离出更多的头文件，所以通常会将 mclog.h 这类头文件放入不同功能划分的文件夹中  
没错，你不仅要给功能分类来创建头文件，还要给头文件分类创建文件夹，当然不要忘记我们的命名规则，一切都需要更新项目名称的含义命名  
最终我放入 03/common/mclog.h 路径下，创建了 common 文件夹，我这考虑到后续还有 04 05 文件夹的，我需要将 mclog.h 文件提升到一个更外围的区域，而不是在本篇文章的 03 文件夹内  
common 似乎与 mcpp 项目在名称上毫无关系，但事实是C++项目通常会根据约定俗称的规则将某些文件放入特定名称的文件夹内，我建议你能遵守这个规则

#### 约定俗成的功能划分
~~~
project/
├── bin/       # 编译生成的二进制可执行文件
├── build/     # 存放构建中间产物（由 CMake 等生成）
├── cmake/     # 自定义的 CMake 脚本或模块
├── docs/      # 项目文档（Doxygen, Markdown 等）
├── external/  # 第三方依赖库（Git 子模块或源码）
├── include/   # 公共头文件 (.h, .hpp)
├── lib/       # 编译生成的库文件 (.a, .so, .lib, .dll)
├── scripts/   # 辅助脚本（Python, Bash 等）
├── src/       # 源代码文件 (.cpp, .c)
└── tests/     # 测试代码（单元测试、集成测试）
~~~

你可以尝试遵守这些规则，当然你也可以使用更符合实际项目的划分方式，从 mcpp 项目结构中可以看出，mcpp 并没有遵循上述的规则，但这不影响 mcpp 是一个拥有合理功能划分的项目


## 项目路径
~~~
https://github.com/HellowAmy/mcpp.git
~~~

